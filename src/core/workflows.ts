import fs from "node:fs";
import path from "node:path";
import yaml from "js-yaml";
import { getDb } from "../db/client.js";
import { id, nowIso } from "./utils.js";
import {
  addCandidate,
  getRoles,
  listCandidates,
  upsertOptions,
  upsertRoles,
  evaluateCandidate,
} from "./store.js";
import type { CandidateScoreBreakdown } from "../types.js";

type WorkflowFile = {
  id: string;
  name: string;
  trigger: string;
  runtime: string;
  steps: Array<{ id: string; agent?: string; action?: string }>;
};

const WORKFLOW_DIR = path.resolve(process.cwd(), "resources", "workflows");

export function listWorkflowDefs(): WorkflowFile[] {
  if (!fs.existsSync(WORKFLOW_DIR)) {
    return [];
  }

  return fs
    .readdirSync(WORKFLOW_DIR)
    .filter((f) => f.endsWith(".yml") || f.endsWith(".yaml"))
    .map((file) => {
      const doc = yaml.load(fs.readFileSync(path.resolve(WORKFLOW_DIR, file), "utf8"));
      return doc as WorkflowFile;
    });
}

export function runWorkflow(workflowId: string, arg: string): Record<string, unknown> {
  const runId = id("run");
  const db = getDb();

  db.prepare(
    `INSERT INTO workflow_runs (id, request_id, workflow_id, started_at, ended_at, status, log_json)
     VALUES (?, NULL, ?, ?, NULL, 'running', '[]')`
  ).run(runId, workflowId, nowIso());

  try {
    let result: Record<string, unknown>;
    if (workflowId === "intake-and-roles") {
      result = executeIntakeAndRoles(arg);
    } else if (workflowId === "source-agents-first") {
      result = executeSourceAgentsFirst(arg);
    } else if (workflowId === "source-humans-second") {
      result = executeSourceHumansSecond(arg);
    } else {
      throw new Error(`Unknown workflow: ${workflowId}`);
    }

    db.prepare(
      `UPDATE workflow_runs SET request_id = ?, ended_at = ?, status = 'completed', log_json = ? WHERE id = ?`
    ).run((result.requestId as string | undefined) ?? null, nowIso(), JSON.stringify(result, null, 2), runId);

    return { runId, ...result };
  } catch (error) {
    db.prepare(
      `UPDATE workflow_runs SET ended_at = ?, status = 'failed', log_json = ? WHERE id = ?`
    ).run(nowIso(), JSON.stringify({ error: (error as Error).message }), runId);
    throw error;
  }
}

function executeIntakeAndRoles(goal: string): Record<string, unknown> {
  const requestId = `req_${Date.now()}`;

  const db = getDb();
  db.prepare(
    `INSERT INTO search_requests (id, created_at, goal, constraints_json, resources_json, notes)
     VALUES (?, ?, ?, '[]', '[]', 'Generated by intake-and-roles workflow')`
  ).run(requestId, nowIso(), goal);

  const roles = deriveRolesFromGoal(goal);
  upsertRoles(requestId, roles);

  return { requestId, rolesCreated: roles.length };
}

function executeSourceAgentsFirst(requestId: string): Record<string, unknown> {
  const roles = getRoles(requestId);
  if (!roles.length) {
    throw new Error("No role specs found. Run intake-and-roles first.");
  }

  const topRole = roles[0];
  const mustHaves = topRole.mustHave;
  const agentSeeds = [
    {
      name: "OpenClaw Workflow Ops Pack",
      source: "openclaw_pack",
      url: "https://example.com/openclaw-workflow-ops",
      skills: [...mustHaves.slice(0, Math.min(3, mustHaves.length))],
      signals: ["OpenClaw-compatible workflows", "Deterministic state machine"],
      risks: ["Small maintainer team"],
    },
    {
      name: "GitHub: claw-hiring-automation",
      source: "github",
      url: "https://github.com/example/claw-hiring-automation",
      skills: [...mustHaves.slice(0, Math.min(2, mustHaves.length))],
      signals: ["Recent commits", "Reusable templates"],
      risks: ["Incomplete docs"],
    },
  ];

  const created: string[] = [];
  for (const seed of agentSeeds) {
    const { candidateId } = addCandidate({
      requestId,
      type: "agent",
      name: seed.name,
      source: seed.source,
      url: seed.url,
      summary: `Agent/workflow pack candidate for ${topRole.roleName}`,
      skills: seed.skills,
      signals: seed.signals,
      risks: seed.risks,
    });

    const scores: CandidateScoreBreakdown = {
      requirement_fit: Math.max(6, Math.min(9, seed.skills.length + 5)),
      evidence_strength: 7,
      execution_risk: 6,
      maintainability: 7,
      cost_fit: 8,
      speed_fit: 8,
    };

    evaluateCandidate({
      candidateId,
      roleMustHaves: mustHaves,
      scoreBreakdown: scores,
      pros: ["Maps to must-have role skills", "Faster ramp than net-new implementation"],
      cons: ["Risk: limited maintainers"],
    });
    created.push(candidateId);
  }

  const candidates = listCandidates(requestId, "agent");
  const bestScore = Number(candidates[0]?.score_overall ?? 0);
  const coverage = mustHaves.length
    ? Math.min(100, Math.round((agentSeeds[0].skills.length / mustHaves.length) * 100))
    : 100;
  const risk = 40;

  if (coverage >= 80 && risk <= 50) {
    upsertOptions(requestId, [
      {
        optionName: "Agent-only",
        teamComposition: [{ type: "agent", candidateIds: created }],
        coverage: { mustHaveCoveragePct: coverage, risk },
        pros: "Fast execution; lower monthly cost; deterministic workflows",
        cons: "Potential maintainer bus factor",
        costEstimate: { monthlyUsd: 3500 },
        timeEstimate: { daysToValue: 7 },
        riskEstimate: { level: "medium" },
        recommendedNextStep: "Approve pilot trial with top agent candidate",
      },
    ]);

    return { requestId, mode: "agent-only", candidateCount: candidates.length, decision: "stop" };
  }

  return {
    requestId,
    mode: "needs-humans",
    candidateCount: candidates.length,
    decision: "continue-to-source-humans-second",
  };
}

function executeSourceHumansSecond(requestId: string): Record<string, unknown> {
  const roles = getRoles(requestId);
  if (!roles.length) {
    throw new Error("No role specs found. Run intake-and-roles first.");
  }

  const role = roles[0];
  const humanSeeds = [
    {
      name: "OpenClaw Workflow Engineer Candidate A",
      source: "linkedin",
      url: "https://example.com/profile-a",
      skills: [...role.mustHave],
      signals: ["5 years workflow automation", "Open-source OpenClaw extensions"],
      risks: ["Higher cost band"],
      scores: { requirement_fit: 9, evidence_strength: 8, execution_risk: 7, maintainability: 8, cost_fit: 5, speed_fit: 7 },
    },
    {
      name: "Automation Specialist Candidate B",
      source: "upwork",
      url: "https://example.com/profile-b",
      skills: role.mustHave.slice(0, Math.max(1, role.mustHave.length - 1)),
      signals: ["Strong delivery velocity"],
      risks: ["Missing one must-have"],
      scores: { requirement_fit: 7, evidence_strength: 7, execution_risk: 6, maintainability: 7, cost_fit: 7, speed_fit: 8 },
    },
  ];

  const humanIds: string[] = [];
  for (const seed of humanSeeds) {
    const { candidateId } = addCandidate({
      requestId,
      type: "human",
      name: seed.name,
      source: seed.source,
      url: seed.url,
      summary: `Human candidate for ${role.roleName}`,
      skills: seed.skills,
      signals: seed.signals,
      risks: seed.risks,
    });
    evaluateCandidate({
      candidateId,
      roleMustHaves: role.mustHave,
      scoreBreakdown: seed.scores,
      pros: ["Evidence aligns to role must-haves"],
      cons: seed.risks,
    });
    humanIds.push(candidateId);
  }

  const agentCandidates = listCandidates(requestId, "agent");
  const humanCandidates = listCandidates(requestId, "human");

  upsertOptions(requestId, [
    {
      optionName: "Agent-only",
      teamComposition: [{ type: "agent", candidateIds: agentCandidates.map((c) => c.id) }],
      coverage: { mustHaveCoveragePct: 75 },
      pros: "Lower cost and quick rollout",
      cons: "Coverage gap for complex edge cases",
      costEstimate: { monthlyUsd: 3500 },
      timeEstimate: { daysToValue: 7 },
      riskEstimate: { level: "medium" },
      recommendedNextStep: "Run two-week agent pilot and monitor failures",
    },
    {
      optionName: "Hybrid",
      teamComposition: [
        { type: "agent", candidateIds: agentCandidates.map((c) => c.id).slice(0, 1) },
        { type: "human", candidateIds: humanIds.slice(0, 1) },
      ],
      coverage: { mustHaveCoveragePct: 95 },
      pros: "Best quality and resilience",
      cons: "Higher coordination overhead",
      costEstimate: { monthlyUsd: 12000 },
      timeEstimate: { daysToValue: 10 },
      riskEstimate: { level: "low" },
      recommendedNextStep: "Approve screening for top human and parallel agent integration",
    },
    {
      optionName: "Human-first",
      teamComposition: [{ type: "human", candidateIds: humanIds }],
      coverage: { mustHaveCoveragePct: 90 },
      pros: "Strong nuanced execution",
      cons: "Slow onboarding and higher cost",
      costEstimate: { monthlyUsd: 16000 },
      timeEstimate: { daysToValue: 21 },
      riskEstimate: { level: "medium" },
      recommendedNextStep: "Proceed with interview loop after approval gate",
    },
  ]);

  return {
    requestId,
    mode: "options-generated",
    agentCandidates: agentCandidates.length,
    humanCandidates: humanCandidates.length,
    status: "awaiting-human-approval",
  };
}

function deriveRolesFromGoal(goal: string) {
  const g = goal.toLowerCase();
  const isOpenClaw = g.includes("openclaw") || g.includes("workflow");

  return [
    {
      roleName: isOpenClaw ? "OpenClaw Workflow Engineer" : "Automation Workflow Engineer",
      scope: "Design and implement deterministic staffing workflows with agent-first sequencing.",
      deliverables: [
        "Implement intake-to-decision workflow set",
        "Integrate SQLite persistence for pipeline tracking",
      ],
      successMetrics: [
        "All requests persist state transitions",
        "Agent-first gate executed for every run",
      ],
      mustHave: ["openclaw", "workflow orchestration", "sqlite"],
      niceToHave: ["typescript", "cli design"],
      disqualifiers: ["no evidence of shipping automation systems"],
    },
    {
      roleName: "Staffing Evaluation Engineer",
      scope: "Define and maintain deterministic scoring rubrics and evaluation outputs.",
      deliverables: [
        "Implement rubric scoring and verdict calculation",
        "Produce traceable pros/cons linked to requirements",
      ],
      successMetrics: [
        "All candidates receive structured score breakdown",
        "Missing must-have cap applied consistently",
      ],
      mustHave: ["structured evaluation", "risk analysis"],
      niceToHave: ["talent ops", "policy governance"],
      disqualifiers: ["uses subjective scoring without evidence"],
    },
  ];
}
